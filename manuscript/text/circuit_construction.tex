\section{Ladder Operator Block-Encoding (LOBE)}
\label{sec:lobe}

In this section of the text, we'll do the following:
\subsection{Defining "Block-Encoding"}
\label{subsec:block-encoding}

\subsection{Prior Works}
\label{subsec:prior-works}

\subsubsection{Linear Combination of Unitaries}

\subsubsection{Sparse Block-Encoding of Pairing Hamiltonians}
stuff from Liu et al
\ws{Might ask you to fill this out @Gus}

\subsection{Rescaling of Coefficients Due to Bosonic Terms}
\label{subsec:rescaling}

The inclusion of bosonic ladder operators in our models requires rescaling the coefficients of our Hamiltonian such that they are always normalized and appropriately weighted.
As shown in Eqs. \ref{eq:bosonic-creation} and \ref{eq:bosonic-annihilation}, bosonic ladder operators acquire a coefficient on the state that is proportional to the square-root of the occupation of the state.
From these definitions, it is clear that if we were to apply a block-encoding that contains bosonic ladder operators onto a quantum state, the output quantum state may not be normalized.

To remedy this, we can rescale the coefficients that are picked up by the operators such that the states are always normalized.
In the case of bosonic ladder operators, we can rescale Eqs. \ref{eq:bosonic-creation} and \ref{eq:bosonic-annihilation} by dividing by the square-root of the maximum allowable occupation number plus one such that any coefficient acquired is $< 1$:
\begin{equation}
    \begin{split}
        a_i^\dagger \ket{n_{a_i}} &= \sqrt{\frac{n_{a_i} + 1}{\Omega + 1}} \ket{n_{a_i} + 1} \hspace{1em} when \ket{n_{a_i}} \neq \ket{\Omega} \\
        a_i  \ket{n_{a_i}} &= \sqrt{\frac{n_{a_i}}{\Omega + 1}} \ket{n_{a_i} - 1} \hspace{1.7em} when \ket{n_{a_i}} \neq \ket{0}
    \end{split}
\end{equation}
We do not redefine these equations for the cases where the state is annihilated since they will be the same as in Eqs.  \ref{eq:bosonic-creation} and \ref{eq:bosonic-annihilation}
These rescaled coefficients will be accounted for within the action of the $Select$ oracle as described in Subsubsection \ref{subsubsec:select}.

Since multiple bosonic operators may be present within a single term ($T_l$), then the overall coefficient of the output state will be rescaled by a factor of:
\begin{equation}
    \lambda_{k_l} = (\Omega + 1)^{k_l/2}
\end{equation}
where $k_l$ is the number of bosonic operators included in the term $T_l$.

Different terms within the Hamiltonian may have different numbers of bosonic operators and therefore will have differing rescaling coefficients of $\lambda_{k_l}$.
In order to guarantee that this rescaling is consistent across the different terms, we can classically preprocess the coefficients in the Hamiltonian such that after the block-encoding is applied, all output states have the same bosonic rescaling factor.
If we define $K \equiv \max_l{k_l}$, then we can define the preprocessed coeffieints as:
\begin{equation}
    \alpha_l \rightarrow \frac{\alpha_l}{(\Omega + 1)^{(K - k_l)/2}} \equiv \alpha_l^*
\end{equation}
where the coefficients $\alpha_l^*$ are the rescaled coefficients of the terms.

This preprocessing means that after the block-encoding is applied, all output states will be rescaled by a coefficient of $(\Omega + 1)^{(K)/2}$.
Therefore, the rescaled Hamiltonian that we block-encode is given by:
\begin{equation}
    H^* = \frac{H}{(\Omega + 1)^{K/2}}
\end{equation}
where $H^*$ is the rescaled Hamiltonian.

\subsection{Circuit Construction}
\label{subsec:circuit}

\begin{figure}
    \centering
    \includegraphics[width=8cm]{figures/lobe-block-encoding.pdf}
    \caption{\textbf{Ladder Operator Block-Encoding.}
    }
    \label{fig:lobe}
\end{figure}

In Figure \ref{fig:lobe}, we define the LOBE circuit in terms of generic oracles.
Disregarding the (optional) control qubit ($\ket{\textit{ctrl}}$), the LOBE circuit makes use of 5 qubit registers: $\ket{\textit{index}}$, $\ket{\textit{valid}}$, $\ket{\textit{coeff}}$, $\ket{\psi}$, and $\ket{0^{\otimes \alpha}}$.

The register denoted $\ket{\textit{index}}$ is referred to as the index register and is used to index the terms in the Hamiltonian as is done in LCU constructions. 
The integer representations of the computational basis states of the index register corresponds to the indices $l$ in Eq. \ref{eq:lclo}. 

The register denoted $\ket{\textit{valid}}$ consists of a single qubit and is referred to as the validation qubit.
It serves the same purpose as in \cite{liu2024efficient} which is to denote whether or not the term at the current index ($T_l$) will annihilate the quantum state.
If the term will annihilate the state, then the validation qubit remains in the $\ket{1}$ state such that the branch of the wavefunction stays outside the desired subspace of the block-encoding.
If the term will not annihilate the state, then the validation qubit gets flipped to the $\ket{0}$ state for the term $T_l$.

The register denoted $\ket{\textit{coeff}}$ is referred to as the coefficient register and is used to apply the coefficients associate with the term $T_l$. 
These coefficients include both the coefficients of the terms in the linear combination ($\alpha_l$) as well as the coefficients associated with the bosonic ladder operators.
One qubit is used to apply the $\alpha_l$ coefficient while a separate qubit will be required for each bosonic operator (defined as a creation, annihilation, or occupation operator acting with a positive integer-valued exponent) in the term.

The register denoted $\ket{\psi}$ is referred to as the system register and is used to encode the state of the system.
This register can be broken up into three subsequent registers: the fermionic system $\ket{\psi_b}$, the antifermionic system ($\ket{\psi_d}$), and the bosonic system ($\ket{\psi_a}$).
The encoding studied in this work is outlined in more detail in Subsection \ref{subsec:encoding}.

Finally, the register denoted $\ket{0^{\otimes \alpha}}$ is referred to as the clean ancillae register.
This register includes ancillae qubits that are promised to begin in the $\ket{0}$ state and are returned to this state at the end of the block-encoding circuit.

The LOBE circuit is structured similarly to an LCU circuit in that it involves sequential application of a $\textit{Prepare}$ oracle, a $\textit{Select}$ oracle, and then uncomputing the $\textit{Prepare}$ oracle using the daggered circuit.
In addition to these oracles, a single $X$ gate is applied to the $\ket{\textit{valid}}$ qubit in order to prepare this qubit in the $\ket{1}$ state.
This single $X$ gate is \textit{not} repeated on subsequent applications of the block-encoding.

\subsubsection{Prepare Oracle}
The $\textit{Prepare}$ oracle is applied to the index register to prepare a superposition over the computational basis states of this register.

\textbf{Uniform State Preparation}

The simplest implementation of the $\textit{Prepare}$ oracle is to prepare a uniform superposition over the computational basis states using a series of Hadamard gates on each qubit in the register.
The rescaling condition for this implementation is that the coefficients must be rescaled such that they all have magnitude $\leq 1$.
Let the largest coefficient magnitude be given by $\alpha^* = \max{|\alpha_l|}$.
Then, this rescaling imposes a constant rescaling factor of $\alpha^*$ and we refer to these rescaled coeffifients as $\Tilde{\alpha_l}$.
An additional rescaling factor of $2^{\lceil \log_2{L} \rceil}$ from the uniform superposition results in an overall rescaling of the Hamiltonian by a constant factor of:
\begin{equation}
    \lambda_{usp} = 2^{\lceil \log_2{L} \rceil} \alpha^*
\end{equation}
such that the rescaled Hamiltonian is given by:
\begin{equation}
    \bar{H} = \frac{H^*}{\lambda_{usp}}
\end{equation}

The quantum resource requirements of this implementation of $\textit{Prepare}$ are negligible as no ancillae are required and only Clifford operations (Hadamards) are performed.
However, this implementation of $\textit{Prepare}$ requires that the rescaled coefficients of the terms ($\Tilde{\alpha_l}$) be incorporated within the $\textit{Select}$ oracle which will be described in Subsubsection \ref{subsubsec:select}.

\textbf{Arbitrary State Preparation}

An alternative implementation of $\textit{Prepare}$ is to use the same implementation traditionally used in LCU circuits.
The coefficients are first rescaled by their $L1-norm$:
\begin{equation}
    \lambda_{asp} = \sum_{l=0}^{L-1} |\alpha_l|
\end{equation}
and the rescaled Hamiltonian is given by:
\begin{equation}
    \bar{H} = \frac{H^*}{\lambda_{asp}}
\end{equation}

It should be noted that $\lambda_{asp} \leq \lambda_{usp}$ \ws{with equality when the coefficients of the terms all have equal magnitude (confirm this)} \ws{and give some analytical proof for this bound}.

Then, a state preparation routine is applied that performs the following operation:
\begin{equation}
    \ket{0^{\otimes \lceil \log_2{L} \rceil}} \rightarrow_{\textit{Prepare}} \sum_{l = 0}^{L-1} \sqrt{|\alpha_l| / \lambda_{asp}} \ket{l}
\end{equation}
This results in a weighted superposition over the computational basis states where the squared amplitudes of the basis states are equal to the magnitude of the associated coefficients.

For Hamiltonians that have structure among the coefficients of the terms, implementations of the $\textit{Prepare}$ oracle can be constructed that leverage this structure.
In certain cases, this can drastically reduce the cost of $\textit{Prepare}$ such as is done for the Fermi-Hubbard model in \cite{babbush2018encoding}.
However, when a certain structure cannot be assumed, the Grover-Rudolph algorithm from \cite{grover2002creating} gives a formulaic routine to generate these $\textit{Prepare}$ circuits.

Gover-Rudolph requires $L-1$ rotations, with $1$ being uncontrolled and the others controlled.
The total number of left-elbows is given by:
\begin{equation}
    N_{\textit{left-elbow}} = L + 1 
\end{equation}
with an equal number of right-elbows.
The total number of ancillae is given by:
\begin{equation}
    Q_{asp} = \lceil \log_2{L} \rceil - 2
\end{equation}
It should be noted that these ancillae, which will be returned to $\ket{0}$ after the oracle call completes, will likely be reused in the $\textit{Select}$ oracle and therefore will not contribute to the total qubit requirement of the block-encoding.

Overall, after the bosonic coefficient rescaling is applied and one of these $Prepare$ oracle compilations is chosen and the coefficients rescaled again, the overall rescaling of the Hamiltonian that is block-encoded is given by:
\begin{equation}
    \bar{H} = \frac{H}{(\Omega + 1)^{K/2} \lambda}
\end{equation}
with $\lambda$ being either $\lambda_{usp}$ or $\lambda_{asp}$.

\subsubsection{Select Oracle}
\label{subsubsec:select}


\begin{figure}
    \centering
    \includegraphics[width=16cm]{figures/select-broad.pdf}
    \caption{\textbf{Ladder Operator Select Oracle.}
    }
    \label{fig:select-broad}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=16cm]{figures/select-specific.pdf}
    \caption{\textbf{Ladder Operator Select Oracle.}
    }
    \label{fig:select-specific}
\end{figure}

The $Select$ oracle is shown in Figure \ref{fig:lobe} as the oracle within the blue shaded region.
As is done in standard LCU circuits, the $Select$ oracle is designed such that it applies the term $T_l$ onto the system when the index register is in the computational basis state $\ket{l}$.
In Figure \ref{fig:lobe}, the hexagonal box represents the multiplexing operation given in Figure 7 of \cite{babbush2018encoding} which creates a coherent for-loop over the computational basis states using $L - 1$ left-elbows and $\lceil \log_2{L} \rceil$ ancillae qubits.

In Figure \ref{fig:select-broad}, we depict a broad schematic for applying a single term within the $Select$ oracle in LOBE and in Figure \ref{fig:select-specific} we give a more explicit compilation.
The entire $Select$ oracle can be constructed by applying the circuit for each term ($T_l$) when the ancilla qubit of the multiplexing operator over the index register is in the corresponding computational basis state.

% First, we will give a broad overview of the $Select$ oracle to describe the purpose of each part of the circuit.
Working from left to right, the first operation shown in Figure \ref{fig:select-specific} is the left-elbow of the multiplexor which puts the ancilla qubit in the $\ket{1}$ state when the index register is in the computational basis state $\ket{l}$.
Next, a left-elbow - controlled on the validation qubit being in the $\ket{1}$ state, the index register being in the $\ket{l}$ state, and the system being in a state that will not be annihilated - is applied to produce a new ancilla qubit.
To perform a check on if the state will be annihilated, we control based on the occupation of the fermionic and antifermionic modes.
The controls on the fermionic and antifermionic modes are determined by the operators that are present within the current term.
For each fermionic (antifermionic) creation operator acting on mode $i$, a $0$-control is added on $i^{th}$ fermionic (antifermionic) mode within $\ket{\psi_b}$ ($\ket{\psi_d}$).
Likewise, for each fermionic (antifermionic) annihilation operator acting on mode $i$, a $1$-control is added on $i^{th}$ fermionic (antifermionic) mode within $\ket{\psi_b}$ ($\ket{\psi_d}$).
For each occupation operator acting on a fermionic (or antifermionic) mode, we include a $1$-control on the $i^{th}$ mode since the state gets "zeroed-out" if the mode is unoccupied.
If any of these conditions are not satisfied, then the state should be "zeroed-out" and the ancilla qubit will be in the $\ket{0}$ state for that branch of the wavefunction.
The quantum states that should be "zeroed-out" due to the bosonic operators will be handled when applying the bosonic operators to the system.

After these checks are performed, the bottom ancilla qubit will be in the $\ket{1}$ state if and only if the three conditions are met, indicating that the term $T_l$ should be applied onto the system.
If the ancilla is in the $\ket{1}$ state, the validation qubit is first flipped from $\ket{1}$ to $\ket{0}$ to put the appropriate branch of the wavefunction into the encoded subspace.
Then the term $T_l$ is applied to the system registers as portrayed in the shaded boxes with the dashed borders in Figure \ref{fig:select-specific}.

In Figure \ref{fig:select-specific}, the first shaded box (red) shows the update on the fermionic system corresponding to a single creation or annihilation operator acting on the $i^{th}$ mode.
Since both the creation and annihilation operators flip the occupation and apply a phase dependent on the parity of the occupation of the preceeding modes, they can both be applied using the same circuit.
To apply the appropriate phase, Pauli $Z$ gates are applied on all the fermionic modes for $j < i$.
To flip the occupation of the mode that the ladder operator acts on, a Pauli $X$ gate is applied to the $i^{th}$ fermionic qubit.
This series of gates is repeated for all fermionic creation or annihilation operators.
Many of these gates could be compiled out of the circuit, however, they are all Clifford operations and therefore will not significantly contribute to the cost of the block-encoding.
Fermionic occupation (number) operators will not affect the occupation of the fermionic modes and therefore do not need to be accounted for when updating the state of the system. 
The second shaded box (orange) in Figure \ref{fig:select-specific} portays the application of an antifermionic ladder operator and is constructed in an analogous way, but acts on the corresponding antifermionic modes.

Next, the third shaded box (green) in Figure \ref{fig:select-specific} depicts the action of a bosonic annihilation operator acting on the system.
This box is repeated for each bosonic annihilation operator within the current term.
We begin by accounting for the coefficients associated with applying the annihilation operators onto the system.
To achieve this, we multiplex over the possible occupation states of the corresponding bosonic mode and apply a rotation on a qubit in the coefficient register.
Let $k$ count the number of bosonic operators that have already been applied in this term ($T_l$) and $P$ denote the exponent on the annihilation operator.
A controlled-Ry rotation is applied on the $k^{th}$ qubit in the coefficient register with an angle given by:
\begin{equation}
    \theta(\omega_i, P) \equiv 2 \cos^{-1}{\Big(\sqrt{\frac{\prod_{p=0}^{P-1} \big( \omega_i - p \big)}{\big(\Omega + 1\big)^P}}\Big)}
\end{equation}
where $\omega_i$ is the occupation of the $i^{th}$ bosonic mode that we are currently multiplexed on.

This rotates the $k^{th}$ qubit in the coefficient register such that the amplitude in the $\ket{0}$ state (encoded subspace) is given by:
\begin{equation}
    R_y\Big(\theta(\omega_i, P)\Big) \ket{0} = \sqrt{\frac{\prod_{p=0}^{P-1} \big( \omega_i - p \big)}{\big(\Omega + 1\big)^P}} \ket{0} + \beta \ket{1}
\end{equation}
where $\beta$ is a complex coefficient that normalizes the state of the qubit.
When multiple bosonic ladder operators exist within a single term, these rotations must be applied on separate qubits such that the coefficient of the all-zero state of the coefficient register is the product of these amplitudes. 

For states that should be "zeroed-out" due to these operators, the coefficient picked up will be zero, therefore the state will be completely outside the encoded subspace.
Alternatively, since we are multiplexing over the occupation states of the bosonic mode, one could perform classical logic to determine if the occupation ($\omega_i$) is less than the exponent ($P$).
If the occupation is less than the exponent, the rotation gate is equivalent to a CNOT gate which will clearly flip the state outside of the encoded subspace.

Next, the occupation of the $i^{th}$ bosonic mode is updated by decrementing occupation mode by a value of $P$.
We note that for states that will be "zeroed-out", these decrementers may raise the occupation from $\ket{0}$ to $\ket{\Omega}$, however since these states are already outside of the encoded subspace, we do not need to ensure that the occupation states are consistent.
The circuit for decrementing (or incrementing) the occupation state is shown in Figure \ref{fig:incrementer}.

The fourth shaded box (blue) depicts the application of a bosonic occupation operator and is likewise repeated for each bosonic occupation operator in the term.
For these operators, we do not need to update the occupation of the modes as the occupation states should remain unchanged.
Therefore we only need to apply the bosonic coefficients which we can do in a similar way to what is done for the bosonic annihilation operators. 
The angle of the rotation for these gates is given by:
\begin{equation}
    \phi(\omega_i, R) \equiv 2 \cos^{-1}{\Big(\frac{\prod_{r=0}^{R-1} \big(\omega_i - r \big)}{\big(\Omega + 1\big)^R}\Big)}
\end{equation}
where $R$ is the exponent of the occupation operator.
As was done for the bosonic annihilation operators, these rotations are applied on the $k^{th}$ qubit in the coefficient register such that the amplitude of the all-zero subspace of the coefficient register picks up a factor of:
\begin{equation}
    \frac{\prod_{r=0}^{R-1} \big(\omega_i - r \big)}{\big(\Omega + 1\big)^R}
\end{equation}

Next, the fifth shaded box (purple) shows the application of a bosonic creation operator this box is repeated for each bosonic creation operator in the term.
These operations are analogous to the bosonic annihilation operators.
First, the occupation of the $i^{th}$ bosonic mode is incremented by $S$ using the circuits shown in Figure \ref{fig:incrementer}.
Then, a multiplexor is applied on the $\Omega$ occupation states of the $i^{th}$ bosonic mode and Pauli-Y rotations are applied on the $k^{th}$ qubit in the coefficient register with an angle given by:
\begin{equation}
    \theta^\dagger(\omega_i, S) \equiv 2 \cos^{-1}{\Big(\sqrt{\frac{\prod_{s=0}^{S-1} \big( \omega_i - s \big)}{\big(\Omega + 1\big)^S}}\Big)}
\end{equation}
where $S$ is the exponent of the bosonic creation operator.
Since the occupation states are updated prior to the rotations (as opposed to afterwards in the annihilation operators), the coefficient of the rotations is computed using the same function of the occupation ($\omega_i$) and the exponent ($P$ or $S$) as is used for the annihilation operators.

Once the state of the system is updated and the bosonic coefficients have been applied, the bottom ancilla qubit can be uncomputed (reset to $\ket{0}$).
This can be achieved by applying a Toffoli onto this qubit with a zero-control on the validation qubit and a one-control on the ancilla qubit used for multiplexing over the index register.
\ws{It's not quite clear to me if we can use a right-elbow here instead of a Toffoli since we are changing the states of fermionic/antifermionic modes after the left-elbow. Obviously it's only one Toff so it's not a big deal, but I wanna try to do some derivations for this.}

Next, if the sign of the coefficient of the current term is $-1$, we apply a $- \mathds{1}$ - controlled on the index register being in the state $\ket{l}$ - to the state, regardless of which $Prepare$ oracle is used.
This operation is shown in the sixth shaded box (cyan) with the dotted border to indicate that this operation may or may not be present depending on the sign of the term.
This can be achieved in many ways, but we show an implementation using only Clifford gates in Figure \ref{fig:negative-identity}.

Finally, if the \textit{uniform state perparation} protocol is used for the $Prepare$ oracle, then a controlled Pauli-Y rotation is applied onto the final qubit in the coefficient register.
This is shown in the seventh shaded box (red-orange) with the dotted border to indicate that this operation may or may not be present depending on which $Prepare$ oracle is used.
This rotation is used to account for the rescaled coefficient of the term ($\Tilde{\alpha_l}$) and is achieved by applying a rotation with an angle given by:
\begin{equation}
    \sigma(\Tilde{\alpha_l}) \equiv 2 \cos^{-1}{|\Tilde{\alpha_l}|}
\end{equation}
If the \textit{arbitrary state preparation} protocol is used, then this rotation is not needed as the coefficient of the term is already accounted for and one fewer qubit is needed in the coefficient register.

\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm}, colback=blue!5!white,colframe=blue!75!black,colbacktitle=orange!80!black, title=Alternative Bosonic Operator Implementation,fonttitle=\bfseries, boxed title style={size=small,colframe=orange!50!black}]
    \ws{This needs to be confirmed, but should be much more efficient.}

    Let any series of bosonic operators acting on the $i^{th}$ mode be described by:
    \begin{equation}
        (a_i^\dagger)^R (a_i)^S
    \end{equation}
    where $R$ and $S$ are nonzero integers in the range $[0, \Omega]$.

    We can describe the action of the rescaled operator on the state of the $i^{th}$ bosonic mode with initial occupation $\omega$ as:
    \begin{equation}
        \label{eq:bosonic-operator-action}
        (a_i^\dagger)^R (a_i)^S \ket{\omega} = \prod_{r=0}^{R-1} \big( \sqrt{\frac{\omega - S + r + 1}{\Omega + 1}} \big) \prod_{s=0}^{S-1} \big( \sqrt{\frac{\omega - s}{\Omega + 1}} \big) \ket{\omega + R - S}
    \end{equation}

    This operation can implemented in the block-encoding via a quantum circuit as follows with all operations controlled on the ancilla qubit indicating if the current term should be applied:
    \begin{enumerate}
        \item Apply a Pauli-X gate on the $k^{th}$ qubit in the coefficient register to rotate it completely outside of the encoded subspace
        \item Multiplex over the occupation of the $i^{th}$ bosonic mode for occupation states in the range: $S \leq \omega_i \leq \min(\Omega, \Omega - S + R)$. Any state beginning with an occupation less than $S$ will be "zeroed-out" and therefore can be left outside of the encoded subspace and the multiplexor can ignore these states. Likewise, any state that should end with an occupation greater than $\Omega$ will also be "zeroed-out" and therefore the multiplexor can terminate early.
        \item For each value of $\omega_i$ in the multiplexor, apply a rotation on the $k^{th}$ qubit in the coefficient register of angle $\theta$ given by Eq. \ref{eq:smarter-rot-angle}. The purpose here will be to rotate the qubit back into the encoded subspace with an amplitude in the $\ket{0}$ state equal to the amplitude in Eq. \ref{eq:bosonic-operator-action}. \ws{Need to figure out if this should be an Ry rotation or something else or perhaps a rotation of $\pi - \theta$, etc... regardless I'm confident this is do-able.}
        \item If $S > R$, apply a decrementer to the $i^{th}$ bosonic mode, reducing the occupation by a value of $S - R$.
        \item If $S < R$, apply an incrementer to the $i^{th}$ bosonic mode, increasing the occupation by a value of $R - S$.
        \item If $S = R$, don't do anything
    \end{enumerate}

    \begin{equation}
        \label{eq:smarter-rot-angle}
        \theta(\omega_i, S, R) = 2 \cos^{-1}{\Big(\prod_{r=0}^{R-1} \big( \sqrt{\frac{\omega - S + r + 1}{\Omega + 1}} \big) \prod_{s=0}^{S-1} \big( \sqrt{\frac{\omega - s}{\Omega + 1}} \big)\Big)}
    \end{equation}

    Overall, this implementation would mean that only one multiplexor would be required for each bosonic mode that is being acted upon, instead of one for each bosonic operator in the term.
    Additionally, the multiplexor will have a reduced number of occupation modees to multiplex over, thereby reducing the number of Toffolis required for the multiplexor.
    With this implementation, $K$ is redefined as the maximum number of bosonic modes being acted upon in a single term (instead of the maximum number of bosonic operators within a term) which will reduce the number of qubits needed in the coefficient register.
    Lastly, only one incrementer/decrementer circuit is required since the occupation state will only need to be updated once for each bosonic mode being acted upon.
\end{tcolorbox}

\begin{figure}
    \centering
    \includegraphics[width=16cm]{figures/select-normal-ordering.pdf}
    \caption{\textbf{Ladder Operator Select Oracle - Normal Ordering.}
    }
    \label{fig:select-normal-ordering}
\end{figure}

\subsection{Analytical Cost Analysis}
\label{subsec:analytics}

The minimum number of qubits required for the index register is given by:
\begin{equation}
    Q_{\textit{index}} = \lceil \log_2{L} \rceil
\end{equation}

If we let $K$ denote the maximum number of bosonic operators within a single term, then the minimum number of qubits in the coefficient register is given by:
\begin{equation}
    Q_{\textit{coeff}} = K + 1
\end{equation} 

Using the qubit-efficient encoding described in Subsection \ref{subsec:encoding}, the minimum number of qubits required for the system registers is given by:
\begin{equation}
    \begin{split}
        &Q_{\psi_b} = \Lambda \\
        &Q_{\psi_d} = \Lambda \\
        &Q_{\psi_a} = \Lambda \lceil \log_2{(\Omega + 1)} \rceil
    \end{split}
\end{equation} 

There are numerous space-time tradeoffs that one can make to either reduce the number of ancillae qubits at the cost of more gates or vice versa.
In this work, we opt for compilations that minimize the number of non-Clifford operations at the expense of more ancillae qubits.
With this choice, the number of clean ancillae required is given by:
\begin{equation}
    \alpha = \lceil \log_2{L} \rceil + (B + 1) + \lceil \log_2{(\Omega + 1)} \rceil
\end{equation}
where $\lceil \log_2{L} \rceil$ qubits are used for multiplexing over the index register, $ \lceil \log_2{(\Omega + 1)} \rceil$ qubits are used for multiplexing over the bosonic occupation registers, and $B$ denotes the maximum number of fermionic and antifermionic ladder operators within a single term.
And we assume that any left-elbow with $N$ controls and one ancilla qubit storing the quantum boolean can be decomposed into $N-1$ left-elbows, each using $2$ controls at the expense of $N-1$ total ancillae.

Therefore, the total qubit requirement under these compilation choices - disregarding the control qubit - is given by:
\begin{equation}
    \begin{split}
        N &= Q_{\textit{index}} + 1 + Q_{\textit{coeff}} + Q_{\psi_b} + Q_{\psi_d} + Q_{\psi_a} + \alpha \\
        &= 2 \lceil \log_2{L} \rceil + 2 \Lambda + (\Lambda + 1) \lceil \log_2{(\Omega + 1)} \rceil + B + K + 3
    \end{split}
\end{equation}

\subsection{Example}
\label{subsec:example}
Step-by-step example (intention is to move this to an appendix)
