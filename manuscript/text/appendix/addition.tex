\section{Addition by a Known Classical Value}
\label{sec:addition}

Adding a (known) classical integer ($m$) to a quantum register encoded in binary is a required operation throughout this work:
\begin{equation}
    \label{eq:addition-by-classical-value}
    \ket{n} \rightarrow \ket{n + m}
\end{equation}
In an effort to keep this work self-contained and pedagogical, we review some methods for constructing this operation in this section.

\begin{figure}
    \centering
    \includegraphics[width=8cm]{figures/incrementer.pdf}
    \caption{
        \textbf{Controlled Incrementer} 
        A circuit diagram implementing a controlled incrementer (mod $32$) is shown.
        The controlled incrementer performs the operation $\ket{x} \rightarrow \ket{x + 1}$ when the control qubit is in the $\ket{1}$ state.
        Decrementing the register by $1$ can be achieved by applying Pauli-X gates on each qubit before and after the operation.
    }
    \label{fig:incrementer}
\end{figure}


One option is to use a series of controlled incrementer ($+1$) circuits.
An implementation of an incrementer circuit given by Gideny \cite{Gidney_2015} is shown in Figure \ref{fig:incrementer}.
If $N$ is the number of qubits in the register being incremented, this implementation requires $4(N-1)$ T gates and $N-1$ clean ancillae.
Naively, a series of $m$ incrementers will result in increasing the value of the register by $m \mod 2^N$.

\begin{figure}
    \include{figures/qpic-code/misc/addition-via-incrementers}
    \caption{
        \textbf{Addition via Incrementers} 
        An implementation of addition by a classical value ($11$) (mod $32$) using a series of incrementers is shown.
        An incrementer applied onto a register excluding the least-significant qubit implements a bit-shifted incrementer.
        This effectively increases the value of the register by $2$.
        Addition by the classical value $11$ can be constructed by bit-shifted incrementers adding the values $+8$, $+2$, and $+1$.
        Subtraction by the same value can be achieved by applying Pauli-X gates on each qubit before and after the operation.
    }
    \label{fig:addition-via-incrementers}
\end{figure}


However, an incrementer circuit can also be used to perform addition by a power of $2$ by acting on only the most-significant qubits.
For example, adding the value $8$ can be achieved using an incrementer circuit that treats the $4^{th}$ least significant qubit as the least significant qubit in the incrementer circuit and disregards the $3$ lesser qubits.
A circuit adding any classical value can then be constructed based on the binary representation of the classical number.
A circuit diagram for this construction is shown in Figure \ref{fig:addition-via-incrementers}.
The cost of this construction would require $N$ incrementer circuits requiring $4 \sum_{i=0}^{N - 2} N - i - 1$ T gates in total and $N - 1$ clean ancillae.

Since we are performing modular addition, the same result can also be achieved by subtracting the value $2^N - m$.
As an example, if the classical value is $31$ and $N = 5$, then this can be accomplished using a single decrementer circuit which can be constructed by conjugating an incrementer circuit with Pauli X gates acting on the qubits encoding $\ket{n}$.
The cost of these two methods can be classically determined and the more favorable option can be chosen during compilation.
The upper bound for the number of T gates, regardless of the classical value being added, is $N^2 + N$.
\ws{This scaling was determined numerically, but i think it shouldn't be hard to derive.}


\begin{figure}
    \include{figures/qpic-code/misc/gate-efficient-addition}
    \caption{
        \textbf{Time-Efficient Controlled Addition of $11$}
        Increasing the value of a quantum register by a known classical value can be implemented using clean ancillae and an uncontrolled quantum addition circuit.
        The known classical value is loaded into a clean ancilla register using a series of CNOT gates corresponding to the binary representation of the classical value.
        Then an uncontrolled quantum addition circuit is applied to the two registers.
        Finally, the loading of the classical value is uncomputed.
    }
    \label{fig:addition-gate-efficient}
\end{figure}

Another option is to first load the classical value into an clean ancilla register, controlled on the control qubit, perform \textit{uncontrolled} (modular) addition of the two quantum registers, then ``unload'' the classical value.
If the control is off, then the classical value is not loaded and the uncontrolled addition simply adds the value $0$ and leaves the original register unchanged.
An example diagram for this construction depicting adding the value $m = 11$ to a register with $N = 5$ qubits is shown in Figure \ref{fig:addition-gate-efficient}.

The loading (and unloading) of the classical value only requires CNOTs and therefore does not contribute any non-Clifford resouces, but it does require $N$ clean ancillae.
However, if the $p$ least significant bits of $m$ are zero, then only $N - p$ qubits are required to load $m$ and the $p$ least-significant qubits of $N$ can be omitted from the addition.
Uncontrolled addition of two registers can be performed using $4(N-1)$ T gates and $N - 1$ clean ancillae using the construction for addition shown in Figure 1 of \cite{gidney2018halving}.
Therefore, in total, this compilation will require $4(N - p - 1)$ T gates and $2(N - p) - 1$ clean ancillae.

When $m$ is a power of $2$, then compilation using incrementer circuits uses the same number of T gates, but fewer clean ancillae.
When $m$ is not a power of $2$, then the compilation using uncontrolled quantum addition uses fewer T gates (at the expense of more clean ancillae).
Since $m$ is known during compilation, an implementation can be chosen that results in the fewest required resources.

\begin{figure*}
    \centering
    \includegraphics[width=12cm]{figures/ctrl-add-11-qubit-efficient.pdf}
    \caption{
        \textbf{Space-Efficient Controlled Addition of 11}
        An implementation for increasing the value of a register by a known classical value is shown for the case when the known value is $11$ and the number of qubits in the register is $5$.
        The binary representation of $11$ is $01011$ with the left-most bit being the most-significant.
        The values of these $M$ classical bits can be propagated into the control structure of the controlled quantum addition.
        If the value of the $i^\text{th}$ bit of $M$ is $0$ ($1$), the corresponding control in the circuit is controlled on the $\ket{1}$  ($\ket{0}$) state.
    }
    \label{fig:addition-qubit-efficient-11}
\end{figure*}

\begin{figure}
    \centering
    \includegraphics[width=8cm]{figures/ctrl-add-12-qubit-efficient.pdf}
    \caption{
        \textbf{Space-Efficient Controlled Addition of 12} 
        An implementation for increasing the value of a register by a known classical value is shown for the case when the known value is $12$ ($01100$ in binary) and the number of qubits in the register is $5$.
        When the least-significant bits of $M$ are $0$, the circuit can be bit-shifted, resulting in a lower cost implementation.
        In this case, the two least-significant bits are $0$, so the circuit can be bit-shifted twice.
    }
    \label{fig:addition-qubit-efficient-12}
\end{figure}

Another implementation can be chosen to reduce the number of clean ancillae, which uses the classical information about $m$ to modify the circuit for \textit{controlled} quantum addition.
Controlled addition of two registers can be performed using $4(2N - 3)$ T gates and $2N - 1$ clean ancillae using the construction for addition shown in Figure 4 of \cite{gidney2018halving}.
This circuit can be modified by propagating the classical information about the binary encoding of $m$ into the control structure of the adder circuit, thereby reducing the number of clean ancillae by $N$.
An example diagram showing this propagation in the case where $m = 11$ and $N = 5$ is shown in Figure \ref{fig:addition-qubit-efficient-11}.

Similarly, if the $p$ least-significant bits of $m$ are known to be zero, the addition can be performed beginning with the first non-zero bit of $m$.
An example circuit diagram for the case where $m=12$ ($01100$ in binary) and $N = 5$ is shown in Figure \ref{fig:addition-qubit-efficient-12}.
If the $p$ least significant bits of $m$ are zero, then this circuit uses $4(2(N - p) - 3)$ T gates and $N - p - 1$ clean ancillae.
Since this work primarily focuses on reducing the number of T gates, the quantum resource estimates quoted in this work do not utilize this strategy.
